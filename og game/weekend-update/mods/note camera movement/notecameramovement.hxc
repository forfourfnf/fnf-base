import funkin.play.PlayState;

import funkin.modding.module.Module;
import funkin.util.tools.StringTools;
import funkin.Paths;

import flixel.FlxSprite;
import flixel.FlxG;
import funkin.ui.options.OptionsState;
import funkin.ui.options.PageName;
import flixel.util.FlxSave;
import flixel.tweens.misc.VarTween;
import flixel.tweens.FlxTweenManager;
import flixel.tweens.FlxTween;
import flixel.math.FlxPoint;
import flixel.math.FlxMath;
import Reflect;

import Std;
import Math;

class NoteCameraModule extends Module {
	public function new() {
		super("Note Camera Movement");
		save = new FlxSave();
        save.bind("bolovevo_saves", "BoloVEVO");

		if (save.data.noteCamera == null)
			save.data.noteCamera = true;

		if (save.data.noteCameraOnlyPlayer == null)
			save.data.noteCameraOnlyPlayer = false;

		save.flush();
	}

	var save;

	static var camX:Float = 20.0;
	static var camY:Float = 20.0;

	override function onStateChangeBegin(ev:ScriptEvent) {
		super.onStateChangeBegin(ev);
	}

	override function onStateChangeEnd(ev:ScriptEvent) {
		super.onStateChangeEnd(ev);
		startedTweens.resize(0);
		startValueX.resize(0);
		startValueY.resize(0);

		if(Std.isOfType(ev.targetState, OptionsState)){ // Inject options to the options menu
            var prefs = ev.targetState.pages.get(PageName.Preferences);

			prefs.items.createItem(120,120*prefs.items.length+30,"Note Camera Movement","bold",function(){
				trace("WELCOME TO THE CUM ZONE, ONLY CUM INSIDE ANIME GIRLS!!!");
			});

			prefs.createPrefItemCheckbox("Enable Note Movement","",function(value){
				save.data.noteCamera = value;
				save.flush();
			},save.data.noteCamera);
			prefs.createPrefItemCheckbox("Only player notes","",function(value){
				save.data.noteCameraOnlyPlayer = value;
				save.flush();
			},save.data.noteCameraOnlyPlayer);
		}
		else if (Std.isOfType(ev.targetState,PlayState)){
			state = PlayState.instance;
		}
	}
	

	var state;
	
	override function onDestroy(ev){
		super.onDestroy();
		state = null;
		startedTweens.resize(0);
		startValueX.resize(0);
		startValueY.resize(0);
	}

	var startedTweens:Array<VarTween> = [];
	var startValueX:Array<Float> = [];
	var startValueY:Array<Float> = [];

	override function onUpdate(ev){
		super.onUpdate(ev);

		if (state == null)
			return;

		// This is just an approach, you may find possible bugs if more tweens edit the camera scroll :(
		var index:Int = 0;

			
		if (FlxG.camera.target == null){
		
			var lerpVal:Float = FlxMath.bound(ev.elapsed * 2.4, 0, 1); // Approach lerp

			for (tween in FlxTween.globalManager._tweens){

				if (startedTweens[index] != null && startedTweens[index].finished){
					startedTweens[index] = null;
					startValueX[index] = null;
					startValueY[index] = null;
				}		

				var varTween:VarTween = tween;

				if (varTween == null)
					return;
				
				if (startedTweens[index] == null){

					startedTweens[index] = varTween;

					if (startedTweens[index]._propertyInfos == null)
						return;

					for (property in startedTweens[index]._propertyInfos)
					{
						switch(property.field){
							case "x":
								startValueX[index] = property.startValue;
								
							case "y":
								startValueY[index] = property.startValue; 
						}
					}
				}


				if (varTween._propertyInfos == null)
					return;

				for (property in varTween._propertyInfos)
				{
					if (property.field == null)
						continue;
					switch(property.field){
						case "x":
							if (startValueX[index] != null){
								var rawDestiny = startValueX[index]+FlxG.camera.targetOffset.x;
								property.startValue = FlxMath.lerp(property.startValue,rawDestiny,lerpVal); // Add the note camera offset to the tween startvalue


								state.cameraFollowPoint.x = (property.startValue + property.range) + (FlxG.camera.width/2);
							}
			
						case "y":
							if (startValueY[index] != null){
								var rawDestiny = startValueY[index]+FlxG.camera.targetOffset.y;
								property.startValue = FlxMath.lerp(property.startValue,rawDestiny,lerpVal);

								state.cameraFollowPoint.y = (property.startValue + property.range) + (FlxG.camera.height/2);
							}
					}
				}

				index++;
			}	


		}
	}

	override function onNoteHit(event) {
    	super.onNoteHit(event);

		if (state == null || !save.data.noteCamera)
			return;

		if (state.playerStrumline == null || (!event.note.noteData.getMustHitNote() && save.data.noteCameraOnlyPlayer)) // Check if the note sang is from the player (aka musthit field)
			return;



		FlxG.camera.targetOffset.set(0,0);


		switch(event.note.direction)
		{
			case 0:
				FlxG.camera.targetOffset.x = -camX;
			case 1:
				FlxG.camera.targetOffset.y = camY;
			case 2:
				FlxG.camera.targetOffset.y = -camY;
			case 3:
				FlxG.camera.targetOffset.x = camX;
		}
  	}
}
